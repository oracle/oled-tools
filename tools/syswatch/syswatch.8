.\" Generated by scdoc 1.9.6
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.nh
.ad l
.\" Begin generated content:
.TH "syswatch" "8" "2023-07-20"
.P
.SH NAME
.P
syswatch - Execute user-provided commands on CPU utilization.
.P
.SH SYNOPSIS
.P
syswatch [-h] [-b] [-C NR_CPUS] -s STAT:PERCENTAGE [-t TARGET_DIR]
[-M MAX_FS_UTIL] [-I SECONDS] -c CMD [-c CMD ...]
.P
.SH DESCRIPTION
.P
\fBsyswatch\fR is used to watch CPU utilization and execute user-provided commands
when the configured thresholds are reached.
.P
The tool samples CPU utilization for intervals of \fISECONDS\fR (5 seconds by
default), and if the configured thresholds are reached in that interval, the
commands specified with \fB-c\fR are executed.
.P
At least one threshold to watch must be specified with \fB-s\fR.  If more than one
threshold is specified, i.e. \fB-s\fR is specified more than once, the commands
will only trigger if all the thresholds are reached in a given interval.  These
values are percentages and must be integer values in the range [1, 100].  The
sum of all thresholds must be <= 100.
.P
If \fINR_CPUS\fR is not specified or is <= 0, the cumulative utilization of all
CPUs is used.  Otherwise, the commands trigger only if \fIat least\fR \fINR_CPUS\fR
reach all the configured thresholds in the interval.
.P
Option \fB-c\fR must be specified at least once.  \fICMD\fR must be a valid shell
command.  See \fBUSER COMMAND CONSIDERATIONS\fR for important details.
.P
By default, \fBsyswatch\fR will create logs in subdirectories in
/var/oled/syswatch. If \fB-t\fR is specified, \fITARGET_DIR\fR is used as base
directory instead.  The base directory will be created if missing (either the
default value or the one configured with \fB-t\fR).  See \fBLOGGING\fR for a
description of the logs dumped by the tool.
.P
By default, \fBsyswatch\fR exits once the user-provided commands finish execution
when the CPU utilization thresholds are reached.  If \fB-b\fR is specified, instead
it will continue running indefinitely, it will restart watching once the user
commands finish.
.P
\fBsyswatch\fR monitors the space utilization of the filesystem where logging is
stored (see \fBLOGGING\fR).  If the configured space usage limit is reached,
\fBsyswatch\fR terminates.  The default limit is 85% utilization (i.e. 15% free
space) but this limit can be changed with \fB-M\fR.  This limit is checked when
\fBsyswatch\fR starts running and when the CPU threshold are reached, before
executing the user commands.
.P
\fBsyswatch\fR must be run as root.
.P
.SH OPTIONS
.P
\fB-h\fR
.RS 4
Display help.
.P
.RE
\fB-b\fR
.RS 4
Run \fBsyswatch\fR indefinitely until it's manually terminated.
.P
.RE
\fB-C NR_CPUS\fR
.RS 4
# of CPUs to apply match criteria.  A value <= 0 means apply system
wide.  (default: 0)
.P
.RE
\fB-s STAT:PERCENTAGE\fR
.RS 4
CPU stat utilization to watch.  \fISTAT\fR can be any of the following
values: usr, nice, sys, idle, iowait, irq, soft, steal, guest, gnice.
\fIPERCENTAGE\fR must be an integer in the range [1, 100].
.P
.RE
\fB-t TARGET_DIR\fR
.RS 4
\fITARGET_DIR\fR to store logs (see \fBLOGGING\fR). (default:
/var/oled/syswatch).
.P
.RE
\fB-M MAX_FS_UTIL\fR
.RS 4
Max filesystem utilization, in percentage.  (default: 85)
.P
.RE
\fB-I SECONDS\fR
.RS 4
CPU utilization sampling interval, in seconds.  (default: 5)
.P
.RE
\fB-c CMD\fR
.RS 4
User command to execute when thresholds are reached.
.P
.RE
.SH USER COMMAND CONSIDERATIONS
.P
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.IP \(bu 4
.\}
The user commands are assumed to be valid shell commands, and are executed
within a shell (the equivalent of `sh -c '$CMD'`).

.RE
.P
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.IP \(bu 4
.\}
If more than one command is specified (i.e. \fB-c\fR appears more than once), all
of them are executed in parallel (a separate shell is spawned for each one).

.RE
.P
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.IP \(bu 4
.\}
Each command is execute in its own, dedicated directory (see \fBLOGGING\fR).

.RE
.P
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.IP \(bu 4
.\}
When syswatch is instructed to run indefinitely (\fB-b\fR), CPU utilization
during the time the commands are running will not be accounted; the next
sampling interval will start when the commands finish.  This ensures that CPU
spikes caused by the user commands themselves don't trip the tool.

.RE
.P
.SH LOGGING
.P
Logs are written in \fITARGET_DIR\fR /var/oled/syswatch by default unless this is
changed with \fB-t\fR.
.P
All logs of one \fBsyswatch\fR invocation will be placed in INSTANCE_DIR
$TARGET_DIR/syswatch_<datetime>_<pid>.  Where <datetime> is the date and time
\fBsyswatch\fR started running and <pid> is the PID of that instance.
.P
\fBsyswatch\fR's logs will be at $INSTANCE_DIR/syswatch.log.  If stdout is a TTY,
logging will be written to stdout too.
.P
When utilization thresholds are reached, a directory $INSTANCE_DIR/<datetime>
will be created (<datetime> being the datetime at which the thresholds were
reached) and inside this directory, one directory for every command to be
executed (named after the commands themselves; e.g. for command `echo hello`
directory `echo__hello` will be created).  The commands will be executed with
their $CWD pointing to this latter directory, and stdout/stderr redirected to
file `output` inside that directory.
.P
When \fBsyswatch\fR is ran indefinitely (\fB-b\fR), there will be one
$INSTANCE_DIR/<datetime> directory for every time the thresholds are reached.
.P
.SH DATA COLLECTION
.P
When collecting data for distribution (e.g. to give to support team), it's
recommended to collect the whole \fBsyswatch\fR's INSTANCE_DIR, as described in
\fBLOGGING\fR (e.g. as a *.tar.gz file).  If there where several \fBsyswatch\fR runs,
the whole TARGET_DIR can be collected instead.
.P
.SH EXAMPLES
.P
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.IP \(bu 4
.\}
Collect perf data once 99% sys utilization is reached system-wide:

.RE
.P
.nf
.RS 4
	$ syswatch -s sys:99 -c 'perf record -c -g -F99 -- sleep 15'
.fi
.RE
.P
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.IP \(bu 4
.\}
Run `cmd1` and `cmd2` in parallel when 70% sys and 30% user util is reached:

.RE
.P
.nf
.RS 4
	$ syswatch -s sys:70 -s usr:30 -c 'cmd1' -c 'cmd2'
.fi
.RE
.P
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.IP \(bu 4
.\}
Run `cmd1` and `cmd2` serially and `cmd3` in parallel on 70% user util:

.RE
.P
.nf
.RS 4
	$ syswatch -s usr:70 -c 'cmd1 ; cmd2' -c 'cmd3'
.fi
.RE
.P
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.IP \(bu 4
.\}
Run `cmd` if at least 3 CPUs reach 70% irq and 30% user within intervals of
2 seconds and the filesystem where the logs are stored has at most 80% space
used (i.e. 20% free space):

.RE
.P
.nf
.RS 4
	$ syswatch -s irq:70 -s usr:30 -C 3 -I 2 -c 'cmd' -M 80
.fi
.RE
.P
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.IP \(bu 4
.\}
Run syswatch continuously and run `cmd` every time 85% sys util is reached
and use /tmp/syswatch as base dir for the logs:

.RE
.P
.nf
.RS 4
	$ syswatch -b -s sys:85 -c 'cmd' -t /tmp/syswatch
.fi
.RE
.P
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.IP \(bu 4
.\}
Wait until system reached 90% sys util and exit, then run `cmd`:

.RE
.P
.nf
.RS 4
	$ syswatch -s sys:90 -c true && cmd
.fi
.RE
.P
.SH AUTHOR
.P
Jose Lombera <jose.lombera@oracle.com>
.P
